package com.uob.msproject;

import java.util.ArrayList;
import java.util.HashMap;

import android.content.Context;

/**
 * The sole purpose of this class is to validate the Markov models as well as
 * the HC algorithms
 */
public class CrossValidation {
	public static ArrayList<String> sTrainingSet = new ArrayList<String>();
	public static ArrayList<String> sTestingSet = new ArrayList<String>();
	private final static int INVALID_PATTERN = -1;

	private int mFolds;
	private DbAdapter mAdapter;

	/**
	 * @param folds
	 *           : the number of folds
	 */
	public CrossValidation(int folds, Context cxt) {
		mAdapter = new DbAdapter(cxt, true);
		mFolds = folds;
	}

	public void validate() {
		mAdapter.open();
		
		mAdapter.getTrainingPatterns();

		int testingSetSize = Math.round(PatternSuggestion.sTrainingSet.size() / mFolds);

		for (int i = 0; i < mFolds; i++) {
			// reset the training and the testing sets
			sTrainingSet.clear();
			sTestingSet.clear();

			// populate training and testing sets
			for (int j = 0; j < PatternSuggestion.sTrainingSet.size(); j++) {
				int startingIndex = i * testingSetSize;
				int endingIndex = startingIndex + testingSetSize;
				if (j >= startingIndex && j < endingIndex) {
					sTestingSet.add(PatternSuggestion.sTrainingSet.get(j));
				} else {
					sTrainingSet.add(PatternSuggestion.sTrainingSet.get(j));
				}
			}

			mAdapter.reinitLocalVars();
			mAdapter.calculateUnigramProbabilities();
			mAdapter.calculateBirgramProbabilities();
			mAdapter.calculateTrigramProbabilities();

			test2(10);
		}

		mAdapter.close();
	}

	/**
	 * Generate patterns repeatedly until the an identical pattern is generated.
	 * Count the number of attempts made before convergence
	 */
	private void test1() {
		PatternSuggestion ps = new PatternSuggestion();
		ArrayList<Integer> RMHCcounts = new ArrayList<Integer>();

		try {
			for (int i = 0; i < sTestingSet.size(); i++) {
				String pattern = "";
				int count = 0;
				while (!pattern.equals(sTestingSet.get(i))) {
					pattern = ps.randomMutationHC(100, sTestingSet.get(i));
					count++;
				}

				RMHCcounts.add(count);

				System.out.print("Total number of attempts: " + count);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Run each HC algorithm for a fixed number of iterations, record the
	 * minimum, maximum and average hamming distances generated by each
	 */
	private void test2(int iter) {
		PatternSuggestion ps = new PatternSuggestion();
		HashMap<String, Integer> solsRM = new HashMap<String, Integer>();
		HashMap<String, Integer> solsRR = new HashMap<String, Integer>();
		HashMap<String, Integer> solsS = new HashMap<String, Integer>();
		HashMap<String, Integer> solsSA = new HashMap<String, Integer>();

		for (int i = 0; i < sTestingSet.size(); i++) {
			// RM
			String patternRM = ps.randomMutationHC(iter, sTestingSet.get(i));
			solsRM.put(patternRM, hammingDistance(sTestingSet.get(i), patternRM));
			// RR
			String patternRR = ps.randomRestartHC(iter, 100, sTestingSet.get(i));
			solsRR.put(patternRR, hammingDistance(sTestingSet.get(i), patternRR));
			// S
			String patternS = ps.stochasticHC(iter, 25, sTestingSet.get(i));
			solsS.put(patternS, hammingDistance(sTestingSet.get(i), patternS));
			// SA
			String patternSA = ps.simulatedAnnealing(100.0, 0.5, iter, sTestingSet.get(i));
			solsSA.put(patternSA, hammingDistance(sTestingSet.get(i), patternSA));
		}

		evaluate(solsRM, "RM");
		evaluate(solsRR, "RR");
		evaluate(solsS, "S");
		evaluate(solsSA, "SA");
	}

	/**
	 * Evaluate the performance of each algorithm
	 */
	private void evaluate(HashMap<String, Integer> sols, String algorithm) {
		int minHamming = -1;
		int nCorrect = 0;
		int maxHamming = -1;
		int avgHamming = 0;
		int totalHamming = 0;

		Integer[] hammingArr = (Integer[]) sols.values().toArray();

		for (int i = 0; i < sTestingSet.size(); i++) {
			int hamming = hammingArr[i].intValue();

			if (hamming < minHamming || minHamming == -1) {
				minHamming = hamming;
			}
			if (hamming > maxHamming) {
				maxHamming = hamming;
			}
			if (hamming == 0) {
				nCorrect++;
			}
			totalHamming += hamming;
		}

		avgHamming = totalHamming / sTestingSet.size();

		System.out.println(algorithm + ":");
		System.out.println(String.format(
				"Min. hamming: %d, Max. hamming: %d, Avg. hamming: %d, Number of successful attempts: %d", minHamming,
				maxHamming, avgHamming, nCorrect));
	}

	/**
	 * Measure the hamming distance between two patterns
	 * 
	 * @param orgP
	 *           : the original pattern
	 * @param solP
	 *           : the solution
	 * 
	 */
	public int hammingDistance(String orgP, String solP) {
		if (orgP.length() != solP.length()) {
			return INVALID_PATTERN;
		}

		int res = 0;

		for (int i = 0; i < orgP.length(); i++) {
			if (orgP.charAt(i) != solP.charAt(i))
				res++;
		}

		return res;
	}
}
